{
  "type": "object",
  "required": [
    "apiServer",
    "debugging",
    "dns",
    "etcd",
    "genericDevicePlugin",
    "ingress",
    "kubelet",
    "manifests",
    "network",
    "node",
    "storage",
    "telemetry"
  ],
  "properties": {
    "apiServer": {
      "type": "object",
      "required": [
        "auditLog",
        "namedCertificates",
        "subjectAltNames",
        "tls"
      ],
      "properties": {
        "advertiseAddress": {
          "description": "Kube apiserver advertise address to work around the certificates issue\nwhen requiring external access using the node IP. This will turn into\nthe IP configured in the endpoint slice for kubernetes service. Must be\na reachable IP from pods. Defaults to service network CIDR first\naddress.",
          "type": "string"
        },
        "auditLog": {
          "type": "object",
          "required": [
            "maxFileAge",
            "maxFileSize",
            "maxFiles",
            "profile"
          ],
          "properties": {
            "maxFileAge": {
              "description": "maxFileAge is the maximum number of days to retain old audit log files",
              "type": "integer",
              "default": 0
            },
            "maxFileSize": {
              "description": "maxFileSize is the maximum size in megabytes of the audit log file before it gets rotated",
              "type": "integer",
              "default": 200
            },
            "maxFiles": {
              "description": "maxFiles is the maximum number of rotated audit log files to retain",
              "type": "integer",
              "default": 10
            },
            "profile": {
              "description": "profile is the OpenShift profile specifying a specific logging policy",
              "type": "string",
              "default": "Default"
            }
          }
        },
        "namedCertificates": {
          "description": "List of custom certificates used to secure requests to specific host names",
          "type": "array",
          "items": {
            "description": "NamedCertificateEntry provides certificate details",
            "type": "object",
            "required": [
              "certPath",
              "keyPath",
              "names"
            ],
            "properties": {
              "certPath": {
                "type": "string"
              },
              "keyPath": {
                "type": "string"
              },
              "names": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        },
        "subjectAltNames": {
          "description": "SubjectAltNames added to API server certs",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "tls": {
          "type": "object",
          "required": [
            "cipherSuites",
            "minVersion"
          ],
          "properties": {
            "cipherSuites": {
              "description": "CipherSuites lists the allowed cipher suites that the API server will\naccept and serve. Defaults to cipher suites from the minVersion config\nparameter.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "minVersion": {
              "description": "MinVersion specifies which TLS version is the minimum version of TLS\nto serve from the API server. Allowed values: VersionTLS12, VersionTLS13.\nDefaults to VersionTLS12.",
              "type": "string",
              "default": "VersionTLS12",
              "enum": [
                "VersionTLS12",
                "VersionTLS13"
              ]
            }
          }
        }
      }
    },
    "debugging": {
      "type": "object",
      "required": [
        "logLevel"
      ],
      "properties": {
        "logLevel": {
          "description": "Valid values are: \"Normal\", \"Debug\", \"Trace\", \"TraceAll\".\nDefaults to \"Normal\".",
          "type": "string",
          "default": "Normal"
        }
      }
    },
    "dns": {
      "type": "object",
      "required": [
        "baseDomain"
      ],
      "properties": {
        "baseDomain": {
          "description": "baseDomain is the base domain of the cluster. All managed DNS records will\nbe sub-domains of this base.\n\nFor example, given the base domain `example.com`, router exposed\ndomains will be formed as `*.apps.example.com` by default,\nand API service will have a DNS entry for `api.example.com`,\nas well as \"api-int.example.com\" for internal k8s API access.\n\nOnce set, this field cannot be changed.",
          "type": "string",
          "default": "example.com",
          "example": "microshift.example.com"
        },
        "hosts": {
          "description": "Hosts contains configuration for the hosts file.",
          "type": "object",
          "properties": {
            "file": {
              "description": "File is the path to the hosts file to monitor.\nIf not specified, defaults to \"/etc/hosts\".",
              "type": "string",
              "default": "/etc/hosts",
              "example": "/etc/hosts"
            },
            "status": {
              "description": "Status controls whether the hosts file is enabled or disabled.\nAllowed values are \"Enabled\" and \"Disabled\".\nIf not specified, defaults to \"Disabled\".",
              "type": "string",
              "default": "Disabled",
              "enum": [
                "Enabled",
                "Disabled"
              ],
              "example": "Enabled"
            }
          }
        }
      }
    },
    "etcd": {
      "type": "object",
      "required": [
        "memoryLimitMB"
      ],
      "properties": {
        "memoryLimitMB": {
          "description": "Set a memory limit on the etcd process; etcd will begin paging\nmemory when it gets to this value. 0 means no limit.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "genericDevicePlugin": {
      "type": "object",
      "required": [
        "devices",
        "domain",
        "status"
      ],
      "properties": {
        "devices": {
          "description": "Devices configuration",
          "type": "array",
          "items": {
            "description": "DeviceSpec defines a device that should be discovered and scheduled.\nDeviceSpec allows multiple host devices to be selected and scheduled fungibly under the same name.\nFurthermore, host devices can be composed into groups of device nodes that should be scheduled\nas an atomic unit.",
            "type": "object",
            "required": [
              "groups",
              "name"
            ],
            "properties": {
              "groups": {
                "description": "Groups is a list of groups of devices that should be scheduled under the same name.",
                "type": "array",
                "items": {
                  "description": "Group represents a set of devices that should be grouped and mounted into a container together as one single meta-device.",
                  "type": "object",
                  "properties": {
                    "count": {
                      "description": "Count specifies how many times this group can be mounted concurrently.\nWhen unspecified, Count defaults to 1.",
                      "type": "integer",
                      "default": 1
                    },
                    "paths": {
                      "description": "'paths' is the list of devices of which the device group consists.\nPaths can be globs, in which case each device matched by the path will be schedulable `Count` times.\nWhen the paths have differing cardinalities, that is, the globs match different numbers of devices,\nthe cardinality of each path is capped at the lowest cardinality.\n'paths' is exclusive with 'usbs'.",
                      "type": "array",
                      "items": {
                        "description": "Path represents a file path that should be discovered.",
                        "type": "object",
                        "required": [
                          "path"
                        ],
                        "properties": {
                          "limit": {
                            "description": "Limit specifies up to how many times this device can be used in the group concurrently when other devices\nin the group yield more matches.\nFor example, if one path in the group matches 5 devices and another matches 1 device but has a limit of 10,\nthen the group will provide 5 pairs of devices.\nWhen unspecified, Limit defaults to 1.",
                            "type": "integer",
                            "default": 1
                          },
                          "mountPath": {
                            "description": "MountPath is the file path at which the host device should be mounted within the container.\nWhen unspecified, MountPath defaults to the Path.",
                            "type": "string",
                            "default": "/dev/ttyACM0"
                          },
                          "path": {
                            "description": "Path is the file path of a device in the host.",
                            "type": "string",
                            "default": "/dev/ttyACM0"
                          },
                          "permissions": {
                            "description": "Permissions is the file-system permissions given to the mounted device.\nPermissions apply only to mounts of type `Device`.\nThis can be one or more of:\n* r - allows the container to read from the specified device.\n* w - allows the container to write to the specified device.\n* m - allows the container to create device files that do not yet exist.\nWhen unspecified, Permissions defaults to mrw.",
                            "type": "string",
                            "default": "mrw"
                          },
                          "readOnly": {
                            "description": "ReadOnly specifies whether the path should be mounted read-only.\nReadOnly applies only to mounts of type `Mount`.",
                            "type": "boolean",
                            "default": false
                          },
                          "type": {
                            "description": "Type describes what type of file-system node this Path represents and thus how it should be mounted.\nAllowed values: \"Device\", \"Mount\". When unspecified, type defaults to Device.",
                            "type": "string",
                            "default": "Device",
                            "enum": [
                              "Device",
                              "Mount",
                              ""
                            ]
                          }
                        }
                      }
                    },
                    "usbs": {
                      "description": "'usbs' is the list of USB specifications that this device group consists of.\nA USB device must match exactly on all the given attributes to pass.\n'usbs' is exclusive with 'paths'.",
                      "type": "array",
                      "items": {
                        "description": "USBSpec represents a USB device specification that should be discovered.\nA USB device must match exactly on all the given attributes to pass.",
                        "type": "object",
                        "required": [
                          "product",
                          "serial",
                          "vendor"
                        ],
                        "properties": {
                          "product": {
                            "description": "Product is the USB Product ID of the device to match on.\nIt should have the format \"0x0123\" or \"0123\".",
                            "type": "string"
                          },
                          "serial": {
                            "description": "Serial is the serial number of the device to match on.\nIf specified, it must match exactly.",
                            "type": "string"
                          },
                          "vendor": {
                            "description": "Vendor is the USB Vendor ID of the device to match on.\nIt should have the format \"0x0123\" or \"0123\".",
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                }
              },
              "name": {
                "description": "Name is a unique string representing the kind of device this specification describes.",
                "type": "string",
                "default": "serial"
              }
            }
          }
        },
        "domain": {
          "description": "Domain with which devices will be present in the cluster,\ne.g. device.microshift.io/serial.",
          "type": "string",
          "default": "device.microshift.io"
        },
        "status": {
          "description": "Generic Device Plugin status, can be Enabled or Disabled",
          "type": "string",
          "default": "Disabled",
          "enum": [
            "Enabled",
            "Disabled",
            ""
          ]
        }
      }
    },
    "ingress": {
      "type": "object",
      "required": [
        "listenAddress",
        "ports",
        "routeAdmissionPolicy",
        "status",
        "tuningOptions"
      ],
      "properties": {
        "accessLogging": {
          "description": "accessLogging describes how the client requests should be logged.",
          "type": "object",
          "required": [
            "destination",
            "status"
          ],
          "properties": {
            "destination": {
              "description": "destination is where access logs go.",
              "type": "object",
              "required": [
                "type"
              ],
              "properties": {
                "container": {
                  "description": "container holds parameters for the Container logging destination.\nPresent only if type is Container.",
                  "type": "object",
                  "properties": {
                    "maxLength": {
                      "description": "maxLength is the maximum length of the log message.\n\nValid values are integers in the range 480 to 8192, inclusive.\n\nWhen omitted, the default value is 1024.",
                      "type": "integer",
                      "format": "int32",
                      "default": 1024,
                      "maximum": 8192,
                      "minimum": 480
                    }
                  }
                },
                "syslog": {
                  "description": "syslog holds parameters for a syslog endpoint.  Present only if\ntype is Syslog.",
                  "type": "object",
                  "required": [
                    "address",
                    "port"
                  ],
                  "properties": {
                    "address": {
                      "description": "address is the IP address of the syslog endpoint that receives log\nmessages.",
                      "type": "string"
                    },
                    "facility": {
                      "description": "facility specifies the syslog facility of log messages.\n\nIf this field is empty, the facility is \"local1\".",
                      "type": "string",
                      "enum": [
                        "kern",
                        "user",
                        "mail",
                        "daemon",
                        "auth",
                        "syslog",
                        "lpr",
                        "news",
                        "uucp",
                        "cron",
                        "auth2",
                        "ftp",
                        "ntp",
                        "audit",
                        "alert",
                        "cron2",
                        "local0",
                        "local1",
                        "local2",
                        "local3",
                        "local4",
                        "local5",
                        "local6",
                        "local7"
                      ]
                    },
                    "maxLength": {
                      "description": "maxLength is the maximum length of the log message.\n\nValid values are integers in the range 480 to 4096, inclusive.\n\nWhen omitted, the default value is 1024.",
                      "type": "integer",
                      "format": "int32",
                      "default": 1024,
                      "maximum": 4096,
                      "minimum": 480
                    },
                    "port": {
                      "description": "port is the UDP port number of the syslog endpoint that receives log\nmessages.",
                      "type": "integer",
                      "format": "int32",
                      "maximum": 65535,
                      "minimum": 1
                    }
                  }
                },
                "type": {
                  "description": "type is the type of destination for logs.  It must be one of the\nfollowing:\n\n* Container\n\nThe ingress operator configures the sidecar container named \"logs\" on\nthe ingress controller pod and configures the ingress controller to\nwrite logs to the sidecar.  The logs are then available as container\nlogs.  The expectation is that the administrator configures a custom\nlogging solution that reads logs from this sidecar.  Note that using\ncontainer logs means that logs may be dropped if the rate of logs\nexceeds the container runtime's or the custom logging solution's\ncapacity.\n\n* Syslog\n\nLogs are sent to a syslog endpoint.  The administrator must specify\nan endpoint that can receive syslog messages.  The expectation is\nthat the administrator has configured a custom syslog instance.",
                  "type": "string",
                  "enum": [
                    "Container",
                    "Syslog"
                  ]
                }
              }
            },
            "httpCaptureCookies": {
              "description": "httpCaptureCookies specifies HTTP cookies that should be captured in\naccess logs.  If this field is empty, no cookies are captured.",
              "type": "array",
              "maxItems": 1,
              "items": {
                "description": "IngressControllerCaptureHTTPCookie describes an HTTP cookie that should be\ncaptured.",
                "type": "object",
                "required": [
                  "matchType",
                  "maxLength"
                ],
                "properties": {
                  "matchType": {
                    "description": "matchType specifies the type of match to be performed on the cookie\nname.  Allowed values are \"Exact\" for an exact string match and\n\"Prefix\" for a string prefix match.  If \"Exact\" is specified, a name\nmust be specified in the name field.  If \"Prefix\" is provided, a\nprefix must be specified in the namePrefix field.  For example,\nspecifying matchType \"Prefix\" and namePrefix \"foo\" will capture a\ncookie named \"foo\" or \"foobar\" but not one named \"bar\".  The first\nmatching cookie is captured.",
                    "type": "string",
                    "enum": [
                      "Exact",
                      "Prefix"
                    ]
                  },
                  "maxLength": {
                    "description": "maxLength specifies a maximum length of the string that will be\nlogged, which includes the cookie name, cookie value, and\none-character delimiter.  If the log entry exceeds this length, the\nvalue will be truncated in the log message.  Note that the ingress\ncontroller may impose a separate bound on the total length of HTTP\nheaders in a request.",
                    "type": "integer",
                    "maximum": 1024,
                    "minimum": 1
                  },
                  "name": {
                    "description": "name specifies a cookie name.  Its value must be a valid HTTP cookie\nname as defined in RFC 6265 section 4.1.",
                    "type": "string",
                    "maxLength": 1024,
                    "minLength": 0,
                    "pattern": "^[-!#$%\u0026'*+.0-9A-Z^_`a-z|~]*$"
                  },
                  "namePrefix": {
                    "description": "namePrefix specifies a cookie name prefix.  Its value must be a valid\nHTTP cookie name as defined in RFC 6265 section 4.1.",
                    "type": "string",
                    "maxLength": 1024,
                    "minLength": 0,
                    "pattern": "^[-!#$%\u0026'*+.0-9A-Z^_`a-z|~]*$"
                  }
                }
              },
              "nullable": true,
              "x-kubernetes-list-type": "atomic"
            },
            "httpCaptureHeaders": {
              "description": "httpCaptureHeaders defines HTTP headers that should be captured in\naccess logs.  If this field is empty, no headers are captured.\n\nNote that this option only applies to cleartext HTTP connections\nand to secure HTTP connections for which the ingress controller\nterminates encryption (that is, edge-terminated or reencrypt\nconnections).  Headers cannot be captured for TLS passthrough\nconnections.",
              "type": "object",
              "properties": {
                "request": {
                  "description": "request specifies which HTTP request headers to capture.\n\nIf this field is empty, no request headers are captured.",
                  "type": "array",
                  "items": {
                    "description": "IngressControllerCaptureHTTPHeader describes an HTTP header that should be\ncaptured.",
                    "type": "object",
                    "required": [
                      "maxLength",
                      "name"
                    ],
                    "properties": {
                      "maxLength": {
                        "description": "maxLength specifies a maximum length for the header value.  If a\nheader value exceeds this length, the value will be truncated in the\nlog message.  Note that the ingress controller may impose a separate\nbound on the total length of HTTP headers in a request.",
                        "type": "integer",
                        "minimum": 1
                      },
                      "name": {
                        "description": "name specifies a header name.  Its value must be a valid HTTP header\nname as defined in RFC 2616 section 4.2.",
                        "type": "string",
                        "pattern": "^[-!#$%\u0026'*+.0-9A-Z^_`a-z|~]+$"
                      }
                    }
                  },
                  "nullable": true,
                  "x-kubernetes-list-type": "atomic"
                },
                "response": {
                  "description": "response specifies which HTTP response headers to capture.\n\nIf this field is empty, no response headers are captured.",
                  "type": "array",
                  "items": {
                    "description": "IngressControllerCaptureHTTPHeader describes an HTTP header that should be\ncaptured.",
                    "type": "object",
                    "required": [
                      "maxLength",
                      "name"
                    ],
                    "properties": {
                      "maxLength": {
                        "description": "maxLength specifies a maximum length for the header value.  If a\nheader value exceeds this length, the value will be truncated in the\nlog message.  Note that the ingress controller may impose a separate\nbound on the total length of HTTP headers in a request.",
                        "type": "integer",
                        "minimum": 1
                      },
                      "name": {
                        "description": "name specifies a header name.  Its value must be a valid HTTP header\nname as defined in RFC 2616 section 4.2.",
                        "type": "string",
                        "pattern": "^[-!#$%\u0026'*+.0-9A-Z^_`a-z|~]+$"
                      }
                    }
                  },
                  "nullable": true,
                  "x-kubernetes-list-type": "atomic"
                }
              }
            },
            "httpLogFormat": {
              "description": "httpLogFormat specifies the format of the log message for an HTTP\nrequest.\n\nIf this field is empty, log messages use the implementation's default\nHTTP log format.  For HAProxy's default HTTP log format, see the\nHAProxy documentation:\nhttp://cbonte.github.io/haproxy-dconv/2.0/configuration.html#8.2.3\n\nNote that this format only applies to cleartext HTTP connections\nand to secure HTTP connections for which the ingress controller\nterminates encryption (that is, edge-terminated or reencrypt\nconnections).  It does not affect the log format for TLS passthrough\nconnections.",
              "type": "string",
              "default": ""
            },
            "status": {
              "description": "Status of the access logging. If set to \"Enabled\", the router will\nlog all requests to the access log. If set to \"Disabled\", the router\nwill not log any requests to the access log.",
              "type": "string",
              "default": "Disabled",
              "enum": [
                "Disabled",
                "Enabled"
              ]
            }
          }
        },
        "certificateSecret": {
          "description": "ServingCertificateSecret references a kubernetes.io/tls type secret containing the TLS cert info for serving secure traffic.\nThe secret must exist in the openshift-ingress namespace and contain the following required fields:\n- Secret.Data[\"tls.key\"] - TLS private key.\n- Secret.Data[\"tls.crt\"] - TLS certificate.",
          "type": "string",
          "default": "router-certs-default"
        },
        "clientTLS": {
          "description": "clientTLS specifies settings for requesting and verifying client\ncertificates, which can be used to enable mutual TLS for\nedge-terminated and reencrypt routes.",
          "type": "object",
          "required": [
            "clientCA",
            "clientCertificatePolicy"
          ],
          "properties": {
            "allowedSubjectPatterns": {
              "description": "allowedSubjectPatterns specifies a list of regular expressions that\nshould be matched against the distinguished name on a valid client\ncertificate to filter requests.  The regular expressions must use\nPCRE syntax.  If this list is empty, no filtering is performed.  If\nthe list is nonempty, then at least one pattern must match a client\ncertificate's distinguished name or else the ingress controller\nrejects the certificate and denies the connection.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "atomic"
            },
            "clientCA": {
              "description": "clientCA specifies a configmap containing the PEM-encoded CA\ncertificate bundle that should be used to verify a client's\ncertificate.  The administrator must create this configmap in the\nopenshift-config namespace.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "name is the metadata.name of the referenced config map",
                  "type": "string"
                }
              }
            },
            "clientCertificatePolicy": {
              "description": "clientCertificatePolicy specifies whether the ingress controller\nrequires clients to provide certificates.  This field accepts the\nvalues \"Required\" or \"Optional\".\n\nNote that the ingress controller only checks client certificates for\nedge-terminated and reencrypt TLS routes; it cannot check\ncertificates for cleartext HTTP or passthrough TLS routes.",
              "type": "string",
              "enum": [
                "",
                "Required",
                "Optional"
              ]
            }
          }
        },
        "defaultHTTPVersion": {
          "description": "Determines default http version should be used for the ingress backends\nBy default,  using version 1.",
          "type": "integer",
          "format": "int32",
          "default": "1"
        },
        "forwardedHeaderPolicy": {
          "description": "forwardedHeaderPolicy specifies when and how ingress router\nsets the Forwarded, X-Forwarded-For, X-Forwarded-Host,\nX-Forwarded-Port, X-Forwarded-Proto, and X-Forwarded-Proto-Version\nHTTP headers.  The value may be one of the following:\n\n* \"Append\", which specifies that ingress router appends the\n  headers, preserving existing headers.\n\n* \"Replace\", which specifies that ingress router sets the\n  headers, replacing any existing Forwarded or X-Forwarded-* headers.\n\n* \"IfNone\", which specifies that ingress router sets the\n  headers if they are not already set.\n\n* \"Never\", which specifies that ingress router never sets the\n  headers, preserving any existing headers.\n\nBy default, the policy is \"Append\".",
          "type": "string",
          "enum": [
            "Append",
            "Replace",
            "IfNone",
            "Never"
          ]
        },
        "httpCompression": {
          "description": "httpCompression defines a policy for HTTP traffic compression.\nBy default, there is no HTTP compression.",
          "type": "object",
          "properties": {
            "mimeTypes": {
              "description": "mimeTypes is a list of MIME types that should have compression applied.\nThis list can be empty, in which case the ingress controller does not apply compression.\n\nNote: Not all MIME types benefit from compression, but HAProxy will still use resources\nto try to compress if instructed to.  Generally speaking, text (html, css, js, etc.)\nformats benefit from compression, but formats that are already compressed (image,\naudio, video, etc.) benefit little in exchange for the time and cpu spent on compressing\nagain. See https://joehonton.medium.com/the-gzip-penalty-d31bd697f1a2",
              "type": "array",
              "items": {
                "description": "CompressionMIMEType defines the format of a single MIME type.\nE.g. \"text/css; charset=utf-8\", \"text/html\", \"text/*\", \"image/svg+xml\",\n\"application/octet-stream\", \"X-custom/customsub\", etc.\n\nThe format should follow the Content-Type definition in RFC 1341:\nContent-Type := type \"/\" subtype *[\";\" parameter]\n  - The type in Content-Type can be one of:\n    application, audio, image, message, multipart, text, video, or a custom\n    type preceded by \"X-\" and followed by a token as defined below.\n  - The token is a string of at least one character, and not containing white\n    space, control characters, or any of the characters in the tspecials set.\n  - The tspecials set contains the characters ()\u003c\u003e@,;:\\\"/[]?.=\n  - The subtype in Content-Type is also a token.\n  - The optional parameter/s following the subtype are defined as:\n    token \"=\" (token / quoted-string)\n  - The quoted-string, as defined in RFC 822, is surrounded by double quotes\n    and can contain white space plus any character EXCEPT \\, \", and CR.\n    It can also contain any single ASCII character as long as it is escaped by \\.",
                "type": "string",
                "pattern": "^(?i)(x-[^][ ()\\\\\u003c\u003e@,;:\"/?.=\\x00-\\x1F\\x7F]+|application|audio|image|message|multipart|text|video)/[^][ ()\\\\\u003c\u003e@,;:\"/?.=\\x00-\\x1F\\x7F]+(; *[^][ ()\\\\\u003c\u003e@,;:\"/?.=\\x00-\\x1F\\x7F]+=([^][ ()\\\\\u003c\u003e@,;:\"/?.=\\x00-\\x1F\\x7F]+|\"(\\\\[\\x00-\\x7F]|[^\\x0D\"\\\\])*\"))*$"
              },
              "x-kubernetes-list-type": "set"
            }
          }
        },
        "httpEmptyRequestsPolicy": {
          "description": "httpEmptyRequestsPolicy describes how HTTP connections should be\nhandled if the connection times out before a request is received.\nAllowed values for this field are \"Respond\" and \"Ignore\".  If the\nfield is set to \"Respond\", the ingress controller sends an HTTP 400\nor 408 response, logs the connection (if access logging is enabled),\nand counts the connection in the appropriate metrics.  If the field\nis set to \"Ignore\", the ingress controller closes the connection\nwithout sending a response, logging the connection, or incrementing\nmetrics.  The default value is \"Respond\".\n\nTypically, these connections come from load balancers' health probes\nor Web browsers' speculative connections (\"preconnect\") and can be\nsafely ignored.  However, these requests may also be caused by\nnetwork errors, and so setting this field to \"Ignore\" may impede\ndetection and diagnosis of problems.  In addition, these requests may\nbe caused by port scans, in which case logging empty requests may aid\nin detecting intrusion attempts.",
          "type": "string",
          "default": "Respond",
          "enum": [
            "Respond",
            "Ignore"
          ]
        },
        "httpErrorCodePages": {
          "description": "httpErrorCodePages specifies a configmap with custom error pages.\nThe administrator must create this configmap in the openshift-config namespace.\nThis configmap should have keys in the format \"error-page-\u003cerror code\u003e.http\",\nwhere \u003cerror code\u003e is an HTTP error code.\nFor example, \"error-page-503.http\" defines an error page for HTTP 503 responses.\nCurrently only error pages for 503 and 404 responses can be customized.\nEach value in the configmap should be the full response, including HTTP headers.\nEg- https://raw.githubusercontent.com/openshift/router/fadab45747a9b30cc3f0a4b41ad2871f95827a93/images/router/haproxy/conf/error-page-503.http\nIf this field is empty, the ingress controller uses the default error pages.",
          "type": "object",
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "description": "name is the metadata.name of the referenced config map",
              "type": "string"
            }
          }
        },
        "listenAddress": {
          "description": "List of IP addresses and NIC names where the router will be listening. The NIC\nnames get translated to all their configured IPs dynamically. Defaults to the\nconfigured IPs in the host at MicroShift start.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "logEmptyRequests": {
          "description": "logEmptyRequests specifies how connections on which no request is\nreceived should be logged.  Typically, these empty requests come from\nload balancers' health probes or Web browsers' speculative\nconnections (\"preconnect\"), in which case logging these requests may\nbe undesirable.  However, these requests may also be caused by\nnetwork errors, in which case logging empty requests may be useful\nfor diagnosing the errors.  In addition, these requests may be caused\nby port scans, in which case logging empty requests may aid in\ndetecting intrusion attempts.  Allowed values for this field are\n\"Log\" and \"Ignore\".  The default value is \"Log\".",
          "type": "string",
          "default": "Log",
          "enum": [
            "Log",
            "Ignore"
          ]
        },
        "ports": {
          "type": "object",
          "required": [
            "http",
            "https"
          ],
          "properties": {
            "http": {
              "description": "Default router http port. Must be in range 1-65535.",
              "type": "integer",
              "default": 80
            },
            "https": {
              "description": "Default router https port. Must be in range 1-65535.",
              "type": "integer",
              "default": 443
            }
          }
        },
        "routeAdmissionPolicy": {
          "type": "object",
          "required": [
            "namespaceOwnership"
          ],
          "properties": {
            "namespaceOwnership": {
              "description": "Describes how host name claims across namespaces should be handled.\n\nValue must be one of:\n\n- Strict: Do not allow routes in different namespaces to claim the same host.\n\n- InterNamespaceAllowed: Allow routes to claim different paths of the same\n  host name across namespaces.\n\nIf empty, the default is InterNamespaceAllowed.",
              "type": "string",
              "default": "InterNamespaceAllowed"
            },
            "wildcardPolicy": {
              "description": "wildcardPolicy describes how routes with wildcard policies should\nbe handled for the ingress controller. WildcardPolicy controls use\nof routes [1] exposed by the ingress controller based on the route's\nwildcard policy.\n\n[1] https://github.com/openshift/api/blob/master/route/v1/types.go\n\nNote: Updating WildcardPolicy from WildcardsAllowed to WildcardsDisallowed\nwill cause admitted routes with a wildcard policy of Subdomain to stop\nworking. These routes must be updated to a wildcard policy of None to be\nreadmitted by the ingress controller.\n\nWildcardPolicy supports WildcardsAllowed and WildcardsDisallowed values.\n\nIf empty, defaults to \"WildcardsDisallowed\".",
              "type": "string"
            }
          }
        },
        "status": {
          "description": "Default router status, can be Managed or Removed.",
          "type": "string",
          "default": "Managed"
        },
        "tlsSecurityProfile": {
          "description": "tlsSecurityProfile specifies settings for TLS connections for ingresscontrollers.\n\nIf unset, the default is based on the apiservers.config.openshift.io/cluster resource.\n\nNote that when using the Old, Intermediate, and Modern profile types, the effective\nprofile configuration is subject to change between releases. For example, given\na specification to use the Intermediate profile deployed on release X.Y.Z, an upgrade\nto release X.Y.Z+1 may cause a new profile configuration to be applied to the ingress\ncontroller, resulting in a rollout.",
          "type": "object",
          "properties": {
            "custom": {
              "description": "custom is a user-defined TLS security profile. Be extremely careful using a custom\nprofile as invalid configurations can be catastrophic. An example custom profile\nlooks like this:\n\n  ciphers:\n\n    - ECDHE-ECDSA-CHACHA20-POLY1305\n\n    - ECDHE-RSA-CHACHA20-POLY1305\n\n    - ECDHE-RSA-AES128-GCM-SHA256\n\n    - ECDHE-ECDSA-AES128-GCM-SHA256\n\n  minTLSVersion: VersionTLS11",
              "type": "object",
              "properties": {
                "ciphers": {
                  "description": "ciphers is used to specify the cipher algorithms that are negotiated\nduring the TLS handshake.  Operators may remove entries their operands\ndo not support.  For example, to use DES-CBC3-SHA  (yaml):\n\n  ciphers:\n    - DES-CBC3-SHA",
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "x-kubernetes-list-type": "atomic"
                },
                "minTLSVersion": {
                  "description": "minTLSVersion is used to specify the minimal version of the TLS protocol\nthat is negotiated during the TLS handshake. For example, to use TLS\nversions 1.1, 1.2 and 1.3 (yaml):\n\n  minTLSVersion: VersionTLS11\n\nNOTE: currently the highest minTLSVersion allowed is VersionTLS12",
                  "type": "string",
                  "enum": [
                    "VersionTLS10",
                    "VersionTLS11",
                    "VersionTLS12",
                    "VersionTLS13"
                  ]
                }
              },
              "nullable": true
            },
            "intermediate": {
              "description": "intermediate is a TLS security profile based on:\n\nhttps://wiki.mozilla.org/Security/Server_Side_TLS#Intermediate_compatibility_.28recommended.29\n\nand looks like this (yaml):\n\n  ciphers:\n\n    - TLS_AES_128_GCM_SHA256\n\n    - TLS_AES_256_GCM_SHA384\n\n    - TLS_CHACHA20_POLY1305_SHA256\n\n    - ECDHE-ECDSA-AES128-GCM-SHA256\n\n    - ECDHE-RSA-AES128-GCM-SHA256\n\n    - ECDHE-ECDSA-AES256-GCM-SHA384\n\n    - ECDHE-RSA-AES256-GCM-SHA384\n\n    - ECDHE-ECDSA-CHACHA20-POLY1305\n\n    - ECDHE-RSA-CHACHA20-POLY1305\n\n    - DHE-RSA-AES128-GCM-SHA256\n\n    - DHE-RSA-AES256-GCM-SHA384\n\n  minTLSVersion: VersionTLS12",
              "type": "object",
              "nullable": true
            },
            "modern": {
              "description": "modern is a TLS security profile based on:\n\nhttps://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility\n\nand looks like this (yaml):\n\n  ciphers:\n\n    - TLS_AES_128_GCM_SHA256\n\n    - TLS_AES_256_GCM_SHA384\n\n    - TLS_CHACHA20_POLY1305_SHA256\n\n  minTLSVersion: VersionTLS13",
              "type": "object",
              "nullable": true
            },
            "old": {
              "description": "old is a TLS security profile based on:\n\nhttps://wiki.mozilla.org/Security/Server_Side_TLS#Old_backward_compatibility\n\nand looks like this (yaml):\n\n  ciphers:\n\n    - TLS_AES_128_GCM_SHA256\n\n    - TLS_AES_256_GCM_SHA384\n\n    - TLS_CHACHA20_POLY1305_SHA256\n\n    - ECDHE-ECDSA-AES128-GCM-SHA256\n\n    - ECDHE-RSA-AES128-GCM-SHA256\n\n    - ECDHE-ECDSA-AES256-GCM-SHA384\n\n    - ECDHE-RSA-AES256-GCM-SHA384\n\n    - ECDHE-ECDSA-CHACHA20-POLY1305\n\n    - ECDHE-RSA-CHACHA20-POLY1305\n\n    - DHE-RSA-AES128-GCM-SHA256\n\n    - DHE-RSA-AES256-GCM-SHA384\n\n    - DHE-RSA-CHACHA20-POLY1305\n\n    - ECDHE-ECDSA-AES128-SHA256\n\n    - ECDHE-RSA-AES128-SHA256\n\n    - ECDHE-ECDSA-AES128-SHA\n\n    - ECDHE-RSA-AES128-SHA\n\n    - ECDHE-ECDSA-AES256-SHA384\n\n    - ECDHE-RSA-AES256-SHA384\n\n    - ECDHE-ECDSA-AES256-SHA\n\n    - ECDHE-RSA-AES256-SHA\n\n    - DHE-RSA-AES128-SHA256\n\n    - DHE-RSA-AES256-SHA256\n\n    - AES128-GCM-SHA256\n\n    - AES256-GCM-SHA384\n\n    - AES128-SHA256\n\n    - AES256-SHA256\n\n    - AES128-SHA\n\n    - AES256-SHA\n\n    - DES-CBC3-SHA\n\n  minTLSVersion: VersionTLS10",
              "type": "object",
              "nullable": true
            },
            "type": {
              "description": "type is one of Old, Intermediate, Modern or Custom. Custom provides\nthe ability to specify individual TLS security profile parameters.\nOld, Intermediate and Modern are TLS security profiles based on:\n\nhttps://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_configurations\n\nThe profiles are intent based, so they may change over time as new ciphers are developed and existing ciphers\nare found to be insecure.  Depending on precisely which ciphers are available to a process, the list may be\nreduced.\n\nNote that the Modern profile is currently not supported because it is not\nyet well adopted by common software libraries.",
              "type": "string",
              "enum": [
                "Old",
                "Intermediate",
                "Modern",
                "Custom"
              ]
            }
          }
        },
        "tuningOptions": {
          "description": "IngressControllerTuningOptions specifies options for tuning the performance\nof ingress controller pods",
          "type": "object",
          "properties": {
            "clientFinTimeout": {
              "description": "clientFinTimeout defines how long a connection will be held open while\nwaiting for the client response to the server/backend closing the\nconnection.\n\nIf unset, the default timeout is 1s",
              "type": "string",
              "format": "duration",
              "default": "1s"
            },
            "clientTimeout": {
              "description": "clientTimeout defines how long a connection will be held open while\nwaiting for a client response.\n\nIf unset, the default timeout is 30s",
              "type": "string",
              "format": "duration",
              "default": "30s"
            },
            "headerBufferBytes": {
              "description": "headerBufferBytes describes how much memory should be reserved\n(in bytes) for IngressController connection sessions.\nNote that this value must be at least 16384 if HTTP/2 is\nenabled for the IngressController (https://tools.ietf.org/html/rfc7540).\nIf this field is empty, the IngressController will use a default value\nof 32768 bytes.\n\nSetting this field is generally not recommended as headerBufferBytes\nvalues that are too small may break the IngressController and\nheaderBufferBytes values that are too large could cause the\nIngressController to use significantly more memory than necessary.",
              "type": "integer",
              "format": "int32",
              "minimum": 16384
            },
            "headerBufferMaxRewriteBytes": {
              "description": "headerBufferMaxRewriteBytes describes how much memory should be reserved\n(in bytes) from headerBufferBytes for HTTP header rewriting\nand appending for IngressController connection sessions.\nNote that incoming HTTP requests will be limited to\n(headerBufferBytes - headerBufferMaxRewriteBytes) bytes, meaning\nheaderBufferBytes must be greater than headerBufferMaxRewriteBytes.\nIf this field is empty, the IngressController will use a default value\nof 8192 bytes.\n\nSetting this field is generally not recommended as\nheaderBufferMaxRewriteBytes values that are too small may break the\nIngressController and headerBufferMaxRewriteBytes values that are too\nlarge could cause the IngressController to use significantly more memory\nthan necessary.",
              "type": "integer",
              "format": "int32",
              "minimum": 4096
            },
            "healthCheckInterval": {
              "description": "healthCheckInterval defines how long the router waits between two consecutive\nhealth checks on its configured backends.  This value is applied globally as\na default for all routes, but may be overridden per-route by the route annotation\n\"router.openshift.io/haproxy.health.check.interval\".\n\nExpects an unsigned duration string of decimal numbers, each with optional\nfraction and a unit suffix, eg \"300ms\", \"1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"µs\" U+00B5 or \"μs\" U+03BC), \"ms\", \"s\", \"m\", \"h\".\n\nSetting this to less than 5s can cause excess traffic due to too frequent\nTCP health checks and accompanying SYN packet storms.  Alternatively, setting\nthis too high can result in increased latency, due to backend servers that are no\nlonger available, but haven't yet been detected as such.\n\nAn empty or zero healthCheckInterval means no opinion and IngressController chooses\na default, which is subject to change over time.\nCurrently the default healthCheckInterval value is 5s.\n\nCurrently the minimum allowed value is 1s and the maximum allowed value is\n2147483647ms (24.85 days).  Both are subject to change over time.",
              "type": "string",
              "default": "5s",
              "pattern": "^(0|([0-9]+(\\.[0-9]+)?(ns|us|µs|μs|ms|s|m|h))+)$"
            },
            "maxConnections": {
              "description": "maxConnections defines the maximum number of simultaneous\nconnections that can be established per HAProxy process.\nIncreasing this value allows each ingress controller pod to\nhandle more connections but at the cost of additional\nsystem resources being consumed.\n\nPermitted values are: empty, 0, -1, and the range\n2000-2000000.\n\nIf this field is empty or 0, the IngressController will use\nthe default value of 50000, but the default is subject to\nchange in future releases.\n\nIf the value is -1 then HAProxy will dynamically compute a\nmaximum value based on the available ulimits in the running\ncontainer. Selecting -1 (i.e., auto) will result in a large\nvalue being computed (~520000 on OpenShift \u003e=4.10 clusters)\nand therefore each HAProxy process will incur significant\nmemory usage compared to the current default of 50000.\n\nSetting a value that is greater than the current operating\nsystem limit will prevent the HAProxy process from\nstarting.\n\nIf you choose a discrete value (e.g., 750000) and the\nrouter pod is migrated to a new node, there's no guarantee\nthat new node has identical ulimits configured. In\nsuch a scenario the pod would fail to start. If you have\nnodes with different ulimits configured (e.g., different\ntuned profiles) and you choose a discrete value then the\nguidance is to use -1 and let the value be computed\ndynamically at runtime.\n\nYou can monitor memory usage for router containers with the\nfollowing metric:\n'container_memory_working_set_bytes{container=\"router\",namespace=\"openshift-ingress\"}'.\n\nYou can monitor memory usage of individual HAProxy\nprocesses in router containers with the following metric:\n'container_memory_working_set_bytes{container=\"router\",namespace=\"openshift-ingress\"}/container_processes{container=\"router\",namespace=\"openshift-ingress\"}'.",
              "type": "integer",
              "format": "int32"
            },
            "serverFinTimeout": {
              "description": "serverFinTimeout defines how long a connection will be held open while\nwaiting for the server/backend response to the client closing the\nconnection.\n\nIf unset, the default timeout is 1s",
              "type": "string",
              "format": "duration",
              "default": "1s"
            },
            "serverTimeout": {
              "description": "serverTimeout defines how long a connection will be held open while\nwaiting for a server/backend response.\n\nIf unset, the default timeout is 30s",
              "type": "string",
              "format": "duration",
              "default": "30s"
            },
            "threadCount": {
              "description": "threadCount defines the number of threads created per HAProxy process.\nCreating more threads allows each ingress controller pod to handle more\nconnections, at the cost of more system resources being used. HAProxy\ncurrently supports up to 64 threads. If this field is empty, the\nIngressController will use the default value.  The current default is 4\nthreads, but this may change in future releases.\n\nSetting this field is generally not recommended. Increasing the number\nof HAProxy threads allows ingress controller pods to utilize more CPU\ntime under load, potentially starving other pods if set too high.\nReducing the number of threads may cause the ingress controller to\nperform poorly.",
              "type": "integer",
              "format": "int32",
              "maximum": 64,
              "minimum": 1
            },
            "tlsInspectDelay": {
              "description": "tlsInspectDelay defines how long the router can hold data to find a\nmatching route.\n\nSetting this too short can cause the router to fall back to the default\ncertificate for edge-terminated or reencrypt routes even when a better\nmatching certificate could be used.\n\nIf unset, the default inspect delay is 5s",
              "type": "string",
              "format": "duration",
              "default": "5s"
            },
            "tunnelTimeout": {
              "description": "tunnelTimeout defines how long a tunnel connection (including\nwebsockets) will be held open while the tunnel is idle.\n\nIf unset, the default timeout is 1h",
              "type": "string",
              "format": "duration",
              "default": "1h"
            }
          }
        }
      }
    },
    "kubelet": {
      "description": "Settings specified in this section are transferred as-is into the Kubelet config."
    },
    "manifests": {
      "type": "object",
      "required": [
        "kustomizePaths"
      ],
      "properties": {
        "kustomizePaths": {
          "description": "The locations on the filesystem to scan for kustomization\nfiles to use to load manifests. Set to a list of paths to scan\nonly those paths. Set to an empty list to disable loading\nmanifests. The entries in the list can be glob patterns to\nmatch multiple subdirectories.",
          "type": "array",
          "default": [
            "/usr/lib/microshift/manifests",
            "/usr/lib/microshift/manifests.d/*",
            "/etc/microshift/manifests",
            "/etc/microshift/manifests.d/*"
          ],
          "items": {
            "type": "string"
          }
        }
      }
    },
    "network": {
      "type": "object",
      "required": [
        "clusterNetwork",
        "multus",
        "serviceNetwork",
        "serviceNodePortRange"
      ],
      "properties": {
        "clusterNetwork": {
          "description": "IP address pool to use for pod IPs.\nThis field is immutable after installation.",
          "type": "array",
          "default": [
            "10.42.0.0/16"
          ],
          "items": {
            "type": "string"
          }
        },
        "cniPlugin": {
          "description": "CNIPlugin is a user defined string value matching one of the above CNI values. MicroShift uses this\nvalue to decide whether to deploy the OVN-K as default CNI. An unset field defaults to \"\" during yaml parsing, and thus\ncould mean that the cluster has been upgraded. In order to support the existing out-of-box behavior, MicroShift\nassumes an empty string to mean the OVN-K should be deployed.\nAllowed values are: unset or one of [\"\", \"ovnk\", \"none\"]",
          "type": "string",
          "enum": [
            "",
            "none",
            "ovnk"
          ]
        },
        "multus": {
          "type": "object",
          "properties": {
            "status": {
              "description": "Status controls the deployment of the Multus CNI.\nChanging from \"Enabled\" to \"Disabled\" will not cause Multus CNI to be deleted.\nAllowed values are: unset (disabled), \"Enabled\", or \"Disabled\"",
              "type": "string",
              "default": "Disabled",
              "enum": [
                "Enabled",
                "Disabled"
              ]
            }
          }
        },
        "serviceNetwork": {
          "description": "IP address pool for services.\nCurrently, we only support a single entry here.\nThis field is immutable after installation.",
          "type": "array",
          "default": [
            "10.43.0.0/16"
          ],
          "items": {
            "type": "string"
          }
        },
        "serviceNodePortRange": {
          "description": "The port range allowed for Services of type NodePort.\nIf not specified, the default of 30000-32767 will be used.\nSuch Services without a NodePort specified will have one\nautomatically allocated from this range.\nThis parameter can be updated after the cluster is\ninstalled.",
          "type": "string",
          "default": "30000-32767",
          "pattern": "^([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])-([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$"
        }
      }
    },
    "node": {
      "type": "object",
      "required": [
        "hostnameOverride",
        "nodeIP",
        "nodeIPv6"
      ],
      "properties": {
        "hostnameOverride": {
          "description": "If non-empty, will use this string to identify the node instead of the hostname",
          "type": "string"
        },
        "nodeIP": {
          "description": "IP address of the node, passed to the kubelet.\nIf not specified, kubelet will use the node's default IP address.",
          "type": "string"
        },
        "nodeIPv6": {
          "description": "IPv6 address of the node, passed to the kubelet. This parameter\nis only allowed when dual stack deployment is configured.",
          "type": "string"
        }
      }
    },
    "storage": {
      "description": "Storage represents a subfield of the MicroShift config data structure. Its purpose to provide a user\nfacing interface to control whether MicroShift should deploy LVMS on startup.",
      "type": "object",
      "properties": {
        "driver": {
          "description": "Driver is a user defined string value matching one of the above CSIStorageDriver values. MicroShift uses this\nvalue to decide whether to deploy the LVMS operator. An unset field defaults to \"\" during yaml parsing, and thus\ncould mean that the cluster has been upgraded. In order to support the existing out-of-box behavior, MicroShift\nassumes an empty string to mean the storage driver should be deployed.\nAllowed values are: unset or one of [\"\", \"lvms\", \"none\"]",
          "type": "string",
          "enum": [
            "",
            "none",
            "lvms"
          ]
        },
        "optionalCsiComponents": {
          "description": "OptionalCSIComponents is a user defined slice of CSIComponent values. These value tell MicroShift which\nadditional, non-driver, CSI controllers to deploy on start. MicroShift will deploy snapshot controller\nwhen no components are specified. This preserves the current deployment behavior of existing\nclusters. Users must set `.storage.optionalCsiComponents: []` to explicitly tell MicroShift not to deploy any CSI\ncomponents. The CSI Driver is excluded as it is typically deployed via the same manifest as the accompanying\nstorage driver. Like CSIStorageDriver, uninstallation is not supported as this can lead to orphaned storage\nobjects.\nAllowed values are: unset, [], or one or more of [\"snapshot-controller\"]",
          "type": "array",
          "items": {
            "description": "OptionalCsiComponent values determine which CSI components MicroShift should deploy. Currently only csi snapshot components\nare supported.",
            "type": "string",
            "enum": [
              "none",
              "snapshot-controller",
              ""
            ]
          },
          "example": [
            "snapshot-controller"
          ]
        }
      }
    },
    "telemetry": {
      "type": "object",
      "required": [
        "endpoint",
        "proxy",
        "status"
      ],
      "properties": {
        "endpoint": {
          "description": "Endpoint where to send telemetry data.",
          "type": "string",
          "default": "https://infogw.api.openshift.com/metrics/v1/receive"
        },
        "proxy": {
          "description": "HTTP proxy to use exclusively for telemetry data. If unset telemetry will\ndefault to use the system configured proxy.",
          "type": "string"
        },
        "status": {
          "description": "Telemetry status, which can be Enabled or Disabled. Defaults to Enabled.",
          "type": "string",
          "default": "Enabled"
        }
      }
    }
  }
}